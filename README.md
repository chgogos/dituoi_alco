# Αλγόριθμοι και πολυπλοκότητα 

**Ακαδημαϊκό έτος 2024-2025**

Γκόγκος Χρήστος, Τμήμα Πληροφορικής και Τηλεπικοινωνιών, Άρτα, Πανεπιστήμιο Ιωαννίνων

Σελίδα ecourse του μαθήματος [ecourse UoI](https://ecourse.uoi.gr/course/view.php?id=1946).

Τελευταία ενημέρωση: 8/1/2025

[Ύλη προόδου](./proodos_20241205.md) - ημερομηνία προόδου 5/12/2024 14:00-16:00
[Ύλη τελικών εξετάσεων](./telikes_20250120.md) 

<!-- - ημερομηνία τελικής εξέτασης 20/1/2025 15:00-18:00 -->

**Παρουσιάσεις από το βιβλίο "Αλγόριθμοι Σχεδίαση και Εφαρμογές" των M. Goodrich και R. Tamassia**

* [<mark>Κεφάλαιο 1</mark>](./resources/ada_book/ch01_gr.pdf) -  Ανάλυση αλγορίθμων
* [<mark>Κεφάλαιο 5Α</mark>](./resources/ada_book/ch05/PriorityQueues_gr.pdf) - Ουρές προτεραιότητας
* [<mark>Κεφάλαιο 5Β</mark>](./resources/ada_book/ch05/Heap_gr.pdf) - Σωροί
* [<mark>Κεφάλαιο 6Α</mark>](./resources/ada_book/ch06/Maps_gr.pdf) - Συσχετιστικοί πίνακες
* [<mark>Κεφάλαιο 6Β</mark>](./resources/ada_book/ch06/HashTables_gr.pdf) - Πίνακες κατακερματισμού
* [<mark>Κεφάλαιο 6Γ</mark>](./resources/ada_book/ch06/CuckooHashing_gr.pdf) - Κατερματισμός κούκου
* [<mark>Κεφάλαιο 7</mark>](./resources/ada_book/ch07_gr.pdf) - Δομή ένωσης/εύρεσης
* [<mark>Κεφάλαιο 8Α</mark>](./resources/ada_book/ch08/MergeSort_gr.pdf) - Ταξινόμηση με συγχώνευση
* [<mark>Κεφάλαιο 8Β</mark>](./resources/ada_book/ch08/QuickSort_gr.pdf) - Γρήγορη ταξινόμηση
* [<mark>Κεφάλαιο 8Γ</mark>](./resources/ada_book/ch08/SortingLowerBound_gr.pdf) - Κάτω όριο ταξινόμησης (με συγκρίσεις)
* [<mark>Κεφάλαιο 10</mark>](./resources/ada_book/ch10_gr.pdf) - Η άπληστη μέθοδος
* [<mark>Κεφάλαιο 11</mark>](./resources/ada_book/ch11_gr.pdf) - Διαίρει και βασίλευε
* [<mark>Κεφάλαιο 12Α</mark>](./resources/ada_book/ch12/DynamicProgramming_gr.pdf) - Δυναμικός Προγραμματισμός: Γινόμενα αλυσίδας πινάκων
* [<mark>Κεφάλαιο 12Β</mark>](./resources/ada_book/ch12/TelescopeSchedule_gr.pdf) - Δυναμικός Προγραμματισμός: Προγραμματισμός τηλεσκοπίων
* [<mark>Κεφάλαιο 12Γ</mark>](./resources/ada_book/ch12/LCS_gr.pdf) - Δυναμικός Προγραμματισμός: Μέγιστη κοινή υποακολουθία
* [<mark>Κεφάλαιο 12Δ</mark>](./resources/ada_book/ch12/Knapsack_gr.pdf) - Δυναμικός Προγραμματισμός: Πρόβλημα σακιδίου 0-1
* [<mark>Κεφάλαιο 13Α</mark>](./resources/ada_book/ch13/Graph_gr.pdf) - Ορολογία και αναπαραστάσεις γράφων
* [<mark>Κεφάλαιο 13Β</mark>](./resources/ada_book/ch13/DFS_gr.pdf) - Αναζήτηση πρώτα σε βάθος
* [<mark>Κεφάλαιο 13Γ</mark>](./resources/ada_book/ch13/BFS_gr.pdf) - Αναζήτηση πρώτα σε πλάτος
* [<mark>Κεφάλαιο 14</mark>](./resources/ada_book/ch14_gr.pdf) - Συντομότερες διαδρομές
* [Κεφάλαιο 15](./resources/ada_book/ch15_gr.pdf) - Δέντρα επικάλυψης ελαχίστου κόστους
* [Κεφάλαιο 16](./resources/ada_book/ch16.pdf) - Μέγιστες ροές
* [<mark>Κεφάλαιο 17Α</mark>](./resources/ada_book/ch17/NPComplete_gr.pdf) - NP πληρότητα
<!-- * [<mark>Κεφάλαιο 18</mark>](./resources/ada_book/ch18_gr.pdf) - Προσεγγιστικοί αλγόριθμοι -->

## Θέματα προετοιμασίας
* [Θέματα προετοιμασίας Α](./resources/recitation-a.pdf)
  * [ΛΥΣΕΙΣ](./resources/recitation-a-solutions.pdf) 📌
* [Θέματα προετοιμασίας Β](./resources/recitation-b.pdf)
  * [ΛΥΣΕΙΣ](./resources/recitation-b-solutions.pdf) 📌

<!-- ## Θέματα παλαιότερων εξετάσεων
* [Θέματα 1](./resources/20220201-ΤΕΛΙΚΗ%20ΓΡΑΠΤΗ%20ΕΞΕΤΑΣΗ.pdf)
* [Θέματα 2](./resources/20220627-ΤΕΛΙΚΗ%20ΓΡΑΠΤΗ%20ΕΞΕΤΑΣΗ.pdf)
* [Θέματα 3](./resources/20220901-ΤΕΛΙΚΗ%20ΓΡΑΠΤΗ%20ΕΞΕΤΑΣΗ.pdf)
* [Θέματα 4](./resources/20231204-ΕΝΔΙΑΜΕΣΗ%20ΕΞΕΤΑΣΗ.pdf)
* [Θέματα 5](./resources/20240129-ΤΕΛΙΚΗ%20ΕΞΕΤΑΣΗ.pdf)
* [Θέματα 6](./resources/20240912Α-ΕΠΑΝΑΛΗΠΤΙΚΗ%20ΕΞΕΤΑΣΗ%20ΣΕΠΤΕΜΒΡΙΟΥ.pdf)
* [Θέματα 7](./resources/20240912Β-ΕΠΑΝΑΛΗΠΤΙΚΗ%20ΕΞΕΤΑΣΗ%20ΣΕΠΤΕΜΒΡΙΟΥ.pdf)
* [Θέματα 8](./resources/20241205-ΕΝΔΙΑΜΕΣΗ%20ΕΞΕΤΑΣΗ.pdf) -->

## 1. Ανάλυση αλγορίθμων
* [Khan's Academy - Asymptotic notation](https://www.khanacademy.org/computing/computer-science/algorithms#asymptotic-notation)
* [Μια εύπεπτη εισαγωγή στην ανάλυση αλγορίθμων](https://discrete.gr/complexity/?el)
* Αντιστροφή λίστας
  * [reverse.ipynb](https://nbviewer.org/github/chgogos/dituoi_alco/blob/main/2023-2024/reverse.ipynb)
  * [reverse.py](./2023-2024/reverse.py)
* Μέγιστος κοινός διαιρέτης καιν ελάχιστο κοινό πολλαπλάσιο
  * [gcd.ipynb](https://nbviewer.org/github/chgogos/dituoi_alco/blob/main/2023-2024/gcd.ipynb)
  * [gcd.py](./2023-2024/gcd.py)
* Το πρόβλημα του "πειραγμένου" νομίσματος 
  * [biased_coin.py](./2023-2024/biased_coin.py)
* [Εντοπισμός μέγιστης τιμής ακολουθίας](./2023-2024/max_array.py)
  * [Stackoverflow: Counting primitive operations on recursive functions](https://stackoverflow.com/questions/68061592/counting-primitive-operations-on-recursive-functions/77266704#77266704)
* Το πρόβλημα της μέγιστης κοινής υποακολουθίας (maxsubarray) [max_subarray.ipynb](https://nbviewer.org/github/chgogos/dituoi_alco/blob/main/2023-2024/max_subarray.ipynb)
* Παραδείγματα με υπολογισμό πολυπλοκότητας σε κώδικα Python [time_complexity.ipynb](https://nbviewer.org/github/chgogos/dituoi_alco/blob/main/2023-2024/time_complexity.ipynb)


## 5. Ουρές προτεραιότητας και σωροί

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/Heap.html) δημιουργίας σωρού ελαχίστων (MINHEAP) με διαδοχικές εισαγωγές τιμών: π.χ. χρησιμοποιήστε το πλήκτρο **Insert** για τη διαδοχική εισαγωγή των τιμών 21,5,17,12,3,9,16 σε έναν σωρό ελαχίστων (David Galles Computer Science University of San Francisco).
* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/Heap.html) δημιουργίας σωρού ελαχίστων (MINHEAP) με τη διαδικασία heapify: χρησιμοποιήστε το πλήκτρο **BuildHeap** για τη δημιουργία ενός σωρού ελαχίστων από έναν πίνακα 31 τιμών με τους ακέραιους από 1 μέχρι και 31 (David Galles Computer Science University of San Francisco).
* [Οπτικοποίηση](https://visualgo.net/en/heap) διαφόρων λειτουργιών σε σωρό μεγίστων (MAXHEAP) από το [visualgo.net](https://visualgo.net/en).

**Ουρές προτεραιότητας στην Python**

* Απλή υλοποίηση σωρού [heap_impl.py](./heap_impl.py)
* Υλοποίηση σωρού της standard βιβλιοθήκης της Python στο module [heapq](https://docs.python.org/3/library/heapq.html)
  * Παράδειγμα: [heapq_example.py](./heapq_example.py)

**Ουρές προτεραιότητας στην C++**

[std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)

Παράδειγμα: [priority_queue_example.cpp](./priority_queue_example.cpp)

**Ουρές προτεραιότητας στην Java**

[PriorityQueue\<E\>](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/PriorityQueue.html)

Παραδείγματα: [Java PriorityQueue by Programiz](https://www.programiz.com/java-programming/priorityqueue)

## 6. Πίνακες αντιστοίχισης     

Οι πίνακες αντιστοίχισης ή συσχετιστικοί πίνακες (associative arrays) ή συσχετιστικές μνήμες (associative memories), ή χάρτες (maps), ή χάρτες κατακερματισμού (hashmaps) ή λεξικά (dictionaries) είναι σύνολα ζευγών κλειδί/τιμή. Υποστηρίζουν τις λειτουργίες εντοπισμού (με δεδομένο το κλειδί), εισαγωγής του ζεύγους κλειδί/τιμή΄και διαγραφής (με δεδομένο το κλειδί) με υψηλή ταχύτητα, Ο(1) υπό προϋποθέσεις. Μπορούμε να θεωρούμε ότι οι πίνακες αντιστοίχισης αναφέρονται στον Αφηρημένο Τύπο Δεδομένων (ΑΤΔ), ενώ όταν υπάρχει στο όνομα η λέξη κατακερματισμός ότι μιλάμε για υλοποίηση του ΑΤΔ με κάποια υλοποίηση πίνακα κατακερματισμού. 

**Λεξικά στην Python**

* [Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)
* [Υλοποίηση των dictionaries στην Python](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented)
* [The python corner - Python Hash Tables: Understanding dictionaries ](https://thepythoncorner.com/posts/2020-08-21-hash-tables-understanding-dictionaries/)

**Πίνακες αντιστοίχισης στη C++**

* [unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map) - υλοποίηση με πίνακα κατακερματισμού
  * Παράδειγμα: [unordered_map_example.cpp](./unordered_map_example.cpp)
* [map](https://en.cppreference.com/w/cpp/container/map) - υλοποίηση πίνακα αντιστοίχισης (με Red-Black δένδρα) με ταξινομημένα κλειδιά 

**Πίνακες αντιστοίχισης στη Java**

* [HashMap](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/HashMap.html)
* [Hash tables in Java](https://www.andreinc.net/2021/11/08/a-tale-of-java-hash-tables)
* [Hashmap in Java](https://www.scaler.com/topics/java/hashmap-in-java/)

### Συναρτήσεις κατακερματισμού

**Μη κρυπτογραφικές συναρτήσεις κατακερματισμού (χρήση σε δομές δεδομένων)**

* [General Purpose Hash Function Algorithms](http://www.partow.net/programming/hashfunctions/index.html#AvailableHashFunctions)
* [djb2, sdbm](http://www.cse.yorku.ca/~oz/hash.html)
* [FNV](http://www.isthe.com/chongo/tech/comp/fnv/)
* [murmur](https://www.sderosiaux.com/articles/2017/08/26/the-murmur3-hash-function--hashtables-bloom-filters-hyperloglog/)

**Κρυπτογραφικές συναρτήσεις κατακερματισμού**

* [SHA256 Hash by Blockchain Demo](https://andersbrownworth.com/blockchain/hash)
* [SlavaSoft HashCalc](https://www.slavasoft.com/hashcalc/)

**Παραδείγματα με hash functions στην Python**

* [interactive_py_hash.py](./interactive_py_hash.py)
* [interactive_py_hash2.py](./interactive_py_hash2.py) κρυπτογραφικες συναρτήσεις κατακερματισμού με το module hashlib

**Ελάχιστη τέλεια συνάρτηση κατακερματισμού (minimal perfect hash function)**

Τέλεια συνάρτηση κατακερματισμού είναι μια συνάρτηση κατακερματισμού η οποία αντιστοιχίζει τα στοιχεία ενός συνόλου σε ένα σύνολο ακεραίων χωρίς συγκρούσεις. Ελάχιστη τέλεια συνάρτηση κατακερματισμού είναι μια τέλεια συνάρτηση κατακερματισμού που αντιστοιχίζει χωρίς συγκρούσεις n κλειδιά σε n διαδοχικούς ακεραίους από το 0 έως το n-1.

Δείτε και το [http://cmph.sourceforge.net/concepts.html](http://cmph.sourceforge.net/concepts.html)

### Ανοικτή διευθυνσιοδότηση (open addressing ή closed hashing) 

Η ανοικτή διευνσιοδότηση λαμβάνει το όνομά της από την ιδιότητα που έχει να επιτρέπει στα κλειδιά να μετακινηθούν και σε άλλες θέσεις, διαφορετικές από τη θέση στην οποία γίνονται αρχικά hash. 

Η ανοικτή διευνσιοδότηση είναι γνωστή και ως κλειστός κατακερματισμός (closed hashing) καθώς τα κλειδία τοποθετούνται μόνο εντός του πίνακα κατακερματισμού και δεν χρησιμοποιείται κάποια άλλη βοηθητική δομή. 

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html) ανοικτής διευθυνσιοδότησης

**Παραλλαγές ανοικτής διευθυνσιοδότησης**

* Γραμμική ανίχνευση (linear probing)
* Τετραγωνική ανίχνευση (quadratic probing)
* Διπλός κατακερματισμός (double hashing)
* Τυχαίος κατακερματισμός (random hashing)

### Κλειστή διευθυνσιοδότηση (closed addressing ή open hashing ή separate chaining)

Η κλειστή διευθυνσιοδότηση λαμβάνει το όνομά της από την ιδιότητα που έχει να τοποθετεί τα κλειδιά στη θέση στην οποία γίνονται hash, χρησιμοποιώντας μια βοηθητική δομή (π.χ. συνδεδεμένη λίστα) για να αποθηκεύσει στην ίδια θέση πιθανώς περισσότερα από ένα στοιχεία τα οποία γίνονται hash στην ίδια θέση. 

Η κλειστή διευθυνσιοδότηση είναι γνωστή και ως ανοικτός κατακερματισμός (open hashing) και ως ξεχωριστή αλυσίδωση (separate chaining). Το όνομα ανοικτός κατακερματισμός προκύπτει καθώς τα κλειδιά δεν είναι απαραίτητο να βρίσκονται εντός του ίδιου του πίνακα κατακερματισμού, αλλά μπορούν να βρίσκονται σε κάποια βοηθητική δομή.

* [Οπτικοποίηση](https://www.cs.usfca.edu/~galles/visualization/OpenHash.html) κλειστής διευθυνσιοδότησης

### Κατακερματισμός κούκου

Ο κατακερματισμός κούκου πετυχαίνει Ο(1) χρόνο χειρότερης περίπτωσης για αναζήτηση και διαγραφή και Ο(1) χρόνο μέσης περίπτωσγης για εισαγωγή.

* [Οπτικοποίηση](https://www.lkozma.net/cuckoo_hashing_visualization/) κατακερματισμού κούκου.

## 7. Δομές Ένωσης-Εύρεσης (disjoint sets)

* [Οπτικοποίηση δομής ένωσης-εύρεσης](https://www.cs.usfca.edu/~galles/visualization/DisjointSets.html) 

**Ασκήσεις**

1. Δίνεται ένα σύνολο από σχέσεις φιλίας ανάμεσα σε άτομα (κάθε άτομο αναπαρίσταται από έναν αριθμό και η σχέση φιλίας με ένα ζεύγος αριθμών). Εντοπίστε τις ομάδες ατόμων που είναι συνδεδεμένες (π.χ. friends = [[ 1, 0 ], [ 2, 3 ], [ 1, 2 ], [ 4, 5 ]]). 

## 8. Αλγόριθμοι Merge-Sort και Quick-Sort

| **Αλγόριθμος**       | **Χρονική Πολυπλοκότητα (Χειρότερη Περίπτωση)** | **Χρονική Πολυπλοκότητα (Μέση Περίπτωση)** | **Χρονική Πολυπλοκότητα (Καλύτερη Περίπτωση)** | **Σταθερή Ταξινόμηση (Stable-Sort)** | **Εντός Θέσης (In-Place)** |
|-----------------------|-------------------------------------------|---------------------------------------|-------------------------------------------|-------------------------|---------------------------|
| **Selection Sort**    | O(n^2)                                    | O(n^2)                                |  O(n^2)                                   | Όχι                     | Ναι                       |
| **Insertion Sort**    | O(n^2)                                    | O(n^2)                                |  O(n)                                     | Ναι                     | Ναι                       |
| **Heap Sort**         | O(n log n)                                | O(n log n)                            |  O(n log n)                               | Όχι                     | Ναι                       |
| **Merge Sort**        | O(n log n)                                | O(n log n)                            |  O(n log n)                               | Ναι                     | Όχι (απαιτεί επιπλέον μνήμη) |
| **Quick Sort**        | O(n^2)                                    | O(n log n)                            |  O(n log n)                               | Όχι                     | Ναι                       |


### Οπτικοποιήσεις Quick-Sort και άλλων αλγορίθμων ταξινόμησης

* <https://opendsa-server.cs.vt.edu/embed/quicksortAV>
* <https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/visualize/>
* <https://mszula.github.io/visual-sorting/>
* <https://www.sortvisualizer.com/>
* <https://tobinatore.github.io/algovis/sorting.html>

### Κάτω όριο για ταξινόμηση βασισμένη σε συγκρίσεις στοιχείων

[Lower bound: Ω(n log n)](https://www.enjoyalgorithms.com/blog/lower-bound-of-comparison-sorting)

### Υλοποιήσεις Merge-Sort και Quick-Sort σε Python

* [sorting_algorithms.py](./sorting_algorithms.py)

### Ταξινόμηση σε διάφορες γλώσσες προγραμματισμού (με κλήσεις συναρτήσεων βιβλιοθηκών)

**Python**

* Ταξινόμηση με την builtin συνάρτηση sorted() της Python και την sort() του NumPy: [sorting_benchmark.py](./sorting_benchmark.py)
* Ταξινόμηση εγγραφών/αντικειμένων με συναρτήσεις της Python: [sorting_records.py](./sorting_records.py) 

**C**

* [sorting_example1.c](./sorting_example1.c)
* [sorting_example2.c](./sorting_example2.c)

**C++**

* [sorting_example1.cpp](./sorting_example1.cpp)
* [sorting_example2.cpp](./sorting_example2.cpp)

**Java**

* [SortingExample1.java](./SortingExample1.java)
* [SortingExample2.java](./SortingExample2.java)


## 10. Άπληστοι Αλγόριθμοι

Οι άπληστοι αλγόριθμοι εφαρμόζονται σε προβλήματα που έχουν:
   * την ιδιότητα της **άπληστης επιλογής (greedy choice property)**, δηλαδή μια βέλτιστη λύση να μπορεί να επιτευχθεί επιλέγοντας τοπικά βέλτιστα.
   * την ιδιότητα της **βέλτιστης υποδομής (optimal substructure property)**, δηλαδή η βέλτιστη λύση να μπορεί να σχηματιστεί με βάση βέλτιστες λύσεις σε  υποπροβλήματα του προβλήματος.

Παραδείγματα προβλημάτων που λύνονται βέλτιστα με την άπληστη μέθοδο: 
* Κλασματικό πρόβλημα σακιδίου (fractional knapsack) 
* Χρονοπρογραμματισμός εργασιών με καθορισμένες στιγμές έναρξης και τερματισμού σε πανομοιότυπες μηχανές με στόχο την ελαχιστοποίηση του πλήθους των μηχανών 
* Κωδικοποίηση Huffmann
* Αλγόριθμος του Dijkstra για την εύρεση των συντομότερων διαδρομών από μια κορυφή προς όλες τις άλλες κορυφές ενός γράφου χωρίς αρνητικά βάρη

### Κωδικοποίηση Huffmann
* <https://ben-tanen.com/adaptive-huffman/>
* <https://www.csfieldguide.org.nz/en/interactives/huffman-tree/>

## 11. Διαίρει και βασίλευε

Διάφορα προβλήματα στα οποία εφαρμόζεται η τεχνική "διαίρει και βασίλευε": 

* Δυαδική αναζήτηση
  * <https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search>
* Merge-Sort
  * <https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/overview-of-merge-sort> 
* Quick-Sort 
  * <https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/overview-of-quicksort>
* Πολλαπλασιασμός ακεραίων με τον αλγόριθμο του Karatsuba
  * <https://brilliant.org/wiki/karatsuba-algorithm/>
  * <https://juris.glaive.pro/blog/karatsuba> 
  * <https://www.quantamagazine.org/the-math-behind-a-faster-multiplication-algorithm-20190923/>
* Πολλαπλασιασμός πινάκων με τον αλγόριθμο του Strassen
  * <https://www.interviewbit.com/blog/strassens-matrix-multiplication/> 
  * <https://www.quantamagazine.org/new-breakthrough-brings-matrix-multiplication-closer-to-ideal-20240307/>
* Σύνολο μεγίστων (maxima set)
  * <https://en.wikipedia.org/wiki/Maxima_of_a_point_set>

* Το [μάστερ θεώρημα](https://brilliant.org/wiki/master-theorem/)
  * [Online επιλυτής 1](https://calculator.pisqre.com/master-theorem)
  * [Online επιλυτής 2](https://www.nayuki.io/page/master-theorem-solver-javascript)

## 12. Δυναμικός προγραμματισμός

Πριν αναφερθούν παραδείγματα δυναμικού προγραμματισμού, θα γίνει μια σύντομη αναφορά στο Brute Force (Ωμή Δύναμη).

Υπολογισμός όλων των δυνατών υποακολουθιών συμβολοσειράς με Brute Force:
* [subsequences1.py](./subsequences1.py) υλοποίηση που χρησιμοποιεί απαρίθμηση δυαδικών αριθμών 
* [subsequences2.py](./subsequences2.py) υλοποίηση που χρησιμοποιεί επαναλήψεις
* [subsequences3.py](./subsequences3.py) υλοποίηση με αναδρομή
* [subsequences4.py](./subsequences4.py) κώδικας που χρησιμοποιεί την υλοποίηση του itertools της Python

**itertools**
* [Python Itertools Part 1 - Product](https://blog.teclado.com/python-itertools-part-1-product/)
* [Python Itertools Part 2 - Combinations & Permutations](https://blog.teclado.com/python-itertools-part-2-combinations-permutations/)

**Αριθμομηχανές υπολογισμού πλήθους διατάξεων (permutations) και πλήθους συνδυασμών (combinations)**
* [Permutations Calculator](https://www.calculatorsoup.com/calculators/discretemathematics/permutations.php)
* [Combinations Calculator](https://www.calculatorsoup.com/calculators/discretemathematics/combinations.php)

Μερικά προβλήματα στα οποία εφαρμόζεται η τεχνική του "δυναμικού προγραμματισμού": 
* Υπολογισμός ν-οστού όρου της [ακολουθίας Fibonacci](https://mathworld.wolfram.com/FibonacciNumber.html) 
  * [fib_recursive.py](./fib_recursive.py) - αναδρομικός αλγόριθμος (πολύ αργός)
  * [fib_dp.py](./fib_dp.py)
  * [fib.py](./fib.py)
* Γινόμενα αλυσίδας πινάκων (MCM - Matrix Chain Multiplication)
  * [MCM](https://www.pisqre.com/calculator/matrix-chain-multiplication)
* Προγραμματισμός τηλεσκοπίων (weighted job scheduling problem)
  * [weighted_job_scheduling.py](./weighted_job_scheduling.py)
* Μέγιστη κοινή υποακολουθία (LCS - Longest Common Subsequence)
  * [LCS](https://www.pisqre.com/calculator/longest-common-sub)
  <!-- * [LCS (another visualiazation)](https://www.cs.usfca.edu/~galles/visualization/DPLCS.html) -->
* Πρόβλημα 0-1 σακιδίου (0-1 knapsack)
  * [0-1 knapsack](https://www.pisqre.com/calculator/knapsack)
* Αλγόριθμος των Floyd-Warshall εύρεσης συντομότερων διαδρομών για όλα τα ζεύγη κορυφών σε γράφο 
  * [Floyd-Warshall](https://www.pisqre.com/calculator/Floyd-Warshall) 

## 13. Γράφοι

* Αναπαράσταση γράφων
   * Λίστα ακμών (edge list)
   * Πίνακας γειτονικότητας (adjacency matrix)
   * Λίστα γειτονικότητας (adjacency list)
   * <https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/describing-graphs>
* Διάσχιση γράφου πρώτα κατά πλάτος, διάσχιση γράφου πρώτα κατά βάθος
   * [graph_traversal.py](./graph_traversal.py) διάσχιση μη κατευθυνόμενου γράφου 
   * [IDEA graph scan](https://idea-instructions.com/graph-scan/)
 * Υλοποιήσεις αλγορίθμων γράφων σε Python
   * https://stackabuse.com/courses/graphs-in-python-theory-and-implementation/
   

**Σχεδίαση γράφων**

* [export_to_graphviz.py](./export_to_graphviz.py) εξαγωγή γράφου σε σχήμα με το graphviz

**Ακυκλικοί κατευθυνόμενοι γράφοι (DAGs = Directed Acyclic Graphs)**

* Τοπολογική ταξινόμηση: τοποθέτηση των κορυφών του DAG σε τέτοια σειρά έτσι ώστε αν υπάρχει ακμή από την κορυφή u στην κορυφή v η κορυφή u να προηγείται στη σειρά της κορυφής v
* Αλγόριθμος του Kahn και αλγόριθμος που χρησιμοποιεί την αναζήτηση πρώτα σε βάθος
  * [topological_sort.py](./topological_sort.py) υλοποιήσεις και των 2 αλγορίθμων τοπολογικής διάταξης
  
**Λαβύρινθοι**

* [mazelib](https://github.com/john-science/mazelib) βιβλιοθήκη στην python για λαβυρίνθους
* [pyamaze](https://github.com/MAN1986/pyamaze) βιβλιοθήκη στην python για λαβυρίνθους

## 14. Συντομότερα μονοπάτια

* Αλγόριθμοι single source shortest paths (sssp)
  * Αλγόριθμος του Dijkstra (άπληστη μέθοδος)
    * [sssp_dijkstra.py](./sssp_dijkstra.py)
    * [nx_sssp_dijkstra.py](./nx_sssp_dijkstra.py)
  * Αλγόριθμος των Bellman-Ford (Δυναμικός Προγραμματισμός)
    * [sssp_bellman_ford.py](./sssp_bellman_ford.py)
    * [nx_sssp_bellman_ford.py](./nx_sssp_bellman_ford.py)
  * Αλγόριθμος εύρεσης συντομότερων μονοπατιών σε DAGs
    * [sssp_dag.py](./sssp_dag.py)
* Αλγόριθμοι all pairs shortest paths (apsp)
  * Αλγόριθμος των Floyd-Warshall (Δυναμικός Προγραμματισμός) 
    * [apsp_floyd_warshall.py](./apsp_floyd_warshall.py)
    * [nx_apsp_floyd_warshall.py](./nx_apsp_floyd_warshall.py)

## 15. Ελάχιστα συνεκτικά δέντρα

* Αλγόριθμος των Prim-Jarnik (χρήση ουράς προτεραιότητας για την υλοποίηση, ενδείκνυται για πυκνούς γράφους)
  * <https://algorithms.discrete.ma.tum.de/graph-algorithms/mst-prim/index_en.html>
* Αλγόριθμος του Kruskal (χρήση ξένων συνόλων για την υλοποίηση, ενδείκνυται για αραιούς γράφους)
  * <https://algorithms.discrete.ma.tum.de/graph-algorithms/mst-kruskal/index_en.html>
* Αλγόριθμος του Borůvka (χρήση παράλληλης ή κατανεμημένης εκτλέλεσης για την υλοποίηση, ενδείκνυται για μεγάλους γράφους)

## 16. Ροή δικτύου και αντιστοίχιση
* Αλγόριθμος των Ford-Fulkerson για εύρεση της μέγιστης ροής (maximum-flow) σε ένα δίκτυο ροής (Network Flow)
  * https://algorithms.discrete.ma.tum.de/graph-algorithms/flow-ford-fulkerson/index_en.html

## 17. NP-πληρότητα

* [Biggest Puzzle in Computer Science: P vs. NP by the Quanta Magazine](https://www.youtube.com/watch?v=pQsdygaYcE4)

<!-- ## 18. Προσεγγιστικοί αλγόριθμοι -->


---

## Aσκήσεις

1. Δίνεται μια ακολουθία μεγάλου μεγέθους με τυχαίες ακέραιες τιμές. Ζητείται να βρεθούν οι 10 πλέον συχνές τιμές χρησιμοποιώντας μια ουρά προτεραιότητας. Αναζητήστε την αποδοτικότερη λύση. Γράψτε πρόγραμμα που να υλοποιεί τη λύση.
   
   * Λύση Α: [heap_exercise1a.py](./heap_exercise1a.py)
   * Λύση Β: [heap_exercise1b.py](./heap_exercise1b.py)

2. Γράψτε πρόγραμμα που να δέχεται τον αριθμό μητρώου και το όνομα, για 10 φοιτητές. Στη συνέχεια να δέχεται επαναληπτικά αριθμούς μητρώου. Αν ο αριθμός μητρώου δεν υπάρχει στους 10 φοιτητές, το πρόγραμμα να τερματίζει, αλλιώς να εμφανίζει το μήνυμα "Γειά σου " ακολουθούμενο από το όνομα του φοιτητή. Να χρησιμοποιηθεί λεξικό (πίνακας κατακερματισμού).

   * [Λύση](./midterm2021_q2.py)

3. Γράψτε πρόγραμμα που με είσοδο ένα μη ταξινομημένο πίνακα A χωρίς διπλότυπα και μια τιμή d, να εκτυπώνει όλα τα ζεύγη τιμών του Α με διαφορά τιμής d. Για παράδειγμα για Α = [1, 5, 6, 2, 7, 4] και d = 3 να εκτυπώνει τα ζεύγη (1,4), (2,5), (4,7). Παρατηρείστε ότι τα ζεύγη εμφανίζονται με πρώτο το μικρότερο στοιχείο κάθε φορά.

   * [Λύση](./midterm2021_q1a.py)
   * [Ταχύτερη λύση](./midterm2021_q1b.py)

4. Έστω ένας μηχανισμός παραγωγής πραγματικών τιμών. Όταν παράγεται μια νέα τιμή να υπολογίζεται και να εμφανίζεται η διάμεσος από όλες τις τιμές που έχουν παραχθεί μέχρι εκείνη τη χρονική στιγμή. Γράψτε πρόγραμμα που να υλοποιεί τη λύση.

   * Σημείωση 1: η διάμεσος μιας λίστας παρατηρήσεων είναι η τιμή της μεσαίας παρατήρησης στη διατεταγμένη σε αύξουσα σειρά λίστας παρατηρήσεων όταν το πλήθος των παρατηρήσεων είναι περιττό, και το ημιάθροισμα των δύο μεσαίων παρατηρήσεων στη διατεταγμένη σε αύξουσα σειρά λίστας παρατηρήσεων όταν όταν το πλήθος των παρατηρήσεων είναι άρτιο. 
   * Σημείωση 2: Προσομοιώστε την παραγωγή πραγματικών τιμών με μια λίστα  τυχαίων πραγματικών τιμών. Θεωρείστε ότι στη χρονική στιγμή 0 παράγεται η τιμή που βρίσκεται στη θέση 0 της λίστας, στη χρονική στιγμή 1 παράγεται η τιμή που βρίσκεται στη θέση 1 της λίστας κ.ο.κ. 

    ```
    Περιγραφή αλγοριθμικής προσέγγισης

    Δημιουργούνται δύο σωροί, ένας σωρός μεγίστων (ΜΑΧHEAP) και ένας σωρός ελαχίστων (MINHEAP). Η ρίζα του MAXHEAP θα πρέπει να είναι μικρότερη από τη ρίζα του MINHEAP. Αν αυτό δεν ισχύει θα πρέπει να μεταφέρεται η ρίζα του ενός από τους δύο σωρούς στον άλλο σωρό έτσι ώστε να επιβληθεί αυτή η συνθήκη. Οι εισαγωγές νέων τιμών θα γίνονται πάντα στον MAXHEAP. Οι δύο σωροί θα πρέπει να έχουν το ίδιο μέγεθος ή ο ένας να είναι κατά 1 μόνο στοιχείο μεγαλύτερος του άλλου και όταν αυτό παραβιάζεται θα μεταφέρεται η ρίζα του μεγαλύτερου σωρού στον μικρότερο σωρό. Η διάμεσος θα είναι είτε η ρίζα του μεγαλύτερου σωρού είτε το ημιάθροισμα των ριζών των δύο σωρών.

    # Ψευδοκώδικας 
    1. Λήψη νέου ακεραίου και προσθήκη στον MAXHEAP.
    2. Αν η ρίζα του MAXHEAP είναι μεγαλύτερη από τη ρίζα του MINHEAP τότε αφαίρεσε τη ρίζα του MAXHEAP και πρόσθεσέ την στον MINHEAP.
    3. Αν το μέγεθος των 2 σωρών διαφέρει κατά 2 αφαίρεσε τη ρίζα από το μεγαλύτερο σωρό και πρόσθεσε την στο μικρότερο σωρό.
    4. Η διάμεσος θα είναι o μέσος όρος των κορυφών των 2 σωρών, αν οι σωροί έχουν το ίδιο μέγεθος ή η ρίζα του μεγαλύτερου από τους 2 σωρούς.
    5. Επιστροφή στο βήμα 1 ή τερματισμός.
    ```

    * Λύση: [heap_exercise2.py](./heap_exercise2.py)

5. Γράψτε ένα πρόγραμμα που να δέχεται έναν πίνακα ακεραίων και μια τιμή sum και να εμφανίζει όλα τα ζεύγη τιμών του πίνακα με άθροισμα ίσο με την τιμή sum.
   * Λύση: [hash_exercise1.py](./hash_exercise1.py)

6. Γράψτε ένα πρόγραμμα που να εντοπίζει σε ένα λεξικό με μεγάλο πλήθος λέξεων όλες τις λέξεις για τις οποίες υπάρχουν τουλάχιστον άλλες 4 λέξεις που είναι αναγραμματισμοί της (π.χ. user -> ['rues', 'ruse', 'suer', 'sure', 'user']).
    * Λύση: [hash_exercise2.py](./hash_exercise2.py)

7. Γράψτε ένα προγραμμα που να εντοπίζει το πλήθος των διακριτών ακεραίων σε μια μεγάλη λίστα ακεραίων.
   * Λύση: [hash_exercise3.py](./hash_exercise3.py)

8. Γράψτε ένα πρόγραμμα που να δέχεται έναν πίνακα διακριτών ακεραίων τιμών και να εμφανίζει τον αριθμό κατάταξης κάθε τιμής του πίνακα (π.χ. για τον πίνακα [17, 13, 21, 19] να επιστρέφει [2, 1, 4, 3])
    * Λύση: [hash_exercise4.py](./hash_exercise4.py)

9.  Γράψτε ένα πρόγραμμα που να υπολογίζει το πλήθος εμφανίσεων των ελληνικών γραμμάτων (Α-Ω, χωρίς διάκριση σε κεφαλαία ή μικρά) σε ένα δεδομένο κείμενο.
    * Λύση: [hash_exercise5.py](./hash_exercise5.py) 

10.  Έστω ότι δίνεται μια λίστα γραμμάτων (letters) και ζητείται ο εντοπισμός όλων των πιθανών λέξεων που μπορούν να εντοπιστούν σε ένα λεξικό (dictionary) και που σχηματίζονται από  οποιαδήποτε διάταξη των γραμμάτων της λίστας. Μπορείτε να χρησιμοποιήσετε το itertools της Python.
  
  ```
  Παράδειγμα εισόδου:
  letters = "cat"
  dictionary = ["cat", "act", "dog", "tac", "bat"]

  Ζητούμενη έξοδος:
  ["cat", "act", "tac"]
  ```

  * Λύση: [brute_force1.py](./brute_force1.py)

 


<!-- 4. Γράψτε πρόγραμμα που να δέχεται μια λίστα τιμών και να επιστρέφει αν υπάρχει υποσύνολο των τιμών  της λίστας με άθροισμα μηδέν.
   
1. Γράψτε ένα πρόγραμμα που να ανιχνεύει αν σε ένα κατευθυνόμενο γράφο υπάρχει κύκλος. -->




## Εκμάθηση Python

* <https://pythoninstitute.org/>
  * [Python Essentials 1](https://pythoninstitute.org/python-essentials-1)
  * [Python Essentials 2](https://pythoninstitute.org/python-essentials-2)
* [Comprehensive Python Cheatsheet](https://gto76.github.io/python-cheatsheet/index.html)

## Εξάσκηση σε διάφορα αλγοριθμικά προβλήματα

* [Leetcode](https://leetcode.com/)
* [Open Kattis](https://open.kattis.com/)
* [Project Euler](https://projecteuler.net/)

---

## Εργασίες παλαιότερων ετών
* [1η εργασία 2021-2022 - το πρόβλημα του μέγιστου υποπίνακα](./assignments/2021-2022-prj1/2021f_project1.pdf)
  <!-- * [Λύση](./assignments/2021-2022-prj1-sol/README.md) -->
* [2η εργασία 2021-2022 - Λαβύρινθος με ξένα σύνολα](./assignments/2021-2022-prj2/2021f_project2.pdf)
* [3η εργασία 2021-2022 - Δυναμικός προγραμματισμός, το πρόβλημα της μέγιστης κοινής υποακολουθίας](./assignments/2021-2022-prj3/2021f_project3.pdf)
* [1η εργασία 2023-2024 - Γρήγορος υπολογισμός συγκεντρωτικών χρεώσεων πιστωτικών καρτών](./assignments/2023-2024-prj1/2023f_alco_prj1.pdf)
* [2η εργασία 2023-2024 - Χρονοπρογραμματισμός εργασιών σε βιομηχανικό περιβάλλον](./assignments/2023-2024-prj2/2023f_alco_prj2.pdf)